rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    ////////////////////////////////
    // Helper functions
    ////////////////////////////////
    function isSignedIn() {
      return request.auth != null;
    }
    function userDoc(uid) {
      return get(/databases/$(database)/documents/users/$(uid));
    }
    function isAdmin() {
      return isSignedIn() && userDoc(request.auth.uid).data.role == 'admin';
    }
    function isOwner(uidField) {
      return isSignedIn() && resource.data[uidField] == request.auth.uid;
    }
    function isOwnerNew(uidField) {
      return isSignedIn() && request.resource.data[uidField] == request.auth.uid;
    }

    // Generic validators
    function stringMax(field, maxLen) {
      return !(field in request.resource.data) || (request.resource.data[field].size() <= maxLen);
    }
    function numberMin(field, minVal) {
      return !(field in request.resource.data) || (request.resource.data[field] >= minVal);
    }
    function allowedStatus(field) {
      return !(field in request.resource.data) || request.resource.data[field] in ['draft','pending','approved','rejected'];
    }

    ////////////////////////////////
    // USERS
    ////////////////////////////////
    // Odczyt ograniczony: publicznie tylko wybrane pola, pełny dokument tylko dla właściciela lub admina
    match /users/{userId} {
      allow read: if isAdmin() || (isSignedIn() && request.auth.uid == userId) || true; // TODO: ograniczyć publiczny zakres pól przez Cloud Functions maskowania
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isSignedIn() && request.auth.uid == userId;
      allow delete: if isAdmin();
    }

    ////////////////////////////////
    // CATEGORIES
    ////////////////////////////////
    match /categories/{categoryId} {
      allow read: if true;
      allow write: if isAdmin();
      match /subcategories/{subcategoryId} {
        allow read: if true;
        allow write: if isAdmin();
      }
      // Kafelki promocyjne kategorii
      match /tiles/{tileId} {
        allow read: if true;
        allow write: if isAdmin();
      }
    }

    ////////////////////////////////
    // DEALS
    ////////////////////////////////
    match /deals/{dealId} {
      // Public read tylko dla approved, autor widzi swoją wersję, admin widzi wszystko
      // Gość widzi tylko approved, autor widzi swoje, admin wszystko
      allow read: if (
        resource.data.status == 'approved' ||
        (isSignedIn() && resource.data.postedBy == request.auth.uid) ||
        isAdmin()
      );
      // Create draft
      // Wymagane pole link
      allow create: if isSignedIn()
        && request.resource.data.postedBy == request.auth.uid
        && request.resource.data.status == 'draft'
        && request.resource.data.temperature == 0
        && request.resource.data.voteCount == 0
        && request.resource.data.commentsCount == 0
        && numberMin('price',0)
        && stringMax('title',160)
        && allowedStatus('status')
        // pozwalamy na nazewnictwo link lub dealUrl (frontend używa dealUrl)
        && (request.resource.data.keys().hasAny(['link']) || request.resource.data.keys().hasAny(['dealUrl']));
      // Update: autor lub admin; dodatkowo osobny przypadek głosowania (tylko temperature & voteCount)
      allow update: if isSignedIn() && (
        resource.data.postedBy == request.auth.uid
        || isAdmin()
        || (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['temperature','voteCount'])
            && request.resource.data.keys().hasAll(resource.data.keys()))
      );
      allow delete: if isAdmin();
    }

    ////////////////////////////////
    // PRODUCTS
    ////////////////////////////////
    match /products/{productId} {
      allow read: if resource.data.status == 'approved' || isAdmin();
      allow create: if isAdmin()
        && request.resource.data.status == 'draft'
        && numberMin('price',0)
        && allowedStatus('status');
      // Update:
      //  - Admin: pełna edycja
      //  - Użytkownik: może edytować tylko ratingCard
      //  - Moderacja: przejście draft->approved / rejected wymaga admina (role=admin)
      allow update: if (
        isAdmin() || (
          isSignedIn() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['ratingCard'])
            && request.resource.data.keys().hasAll(resource.data.keys())
        )
      )
      && (
        // Jeśli zmieniamy status, tylko admin
        !(request.resource.data.status in ['approved','rejected']) || isAdmin()
      );
      allow delete: if isAdmin();
    }

    // Ustawienia globalne (np. konfiguracja nawigacji): dostępne do odczytu dla wszystkich, edycja tylko dla administracji.
    ////////////////////////////////
    // SETTINGS
    ////////////////////////////////
    match /settings/{settingId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Komentarze jako subkolekcje (products/{productId}/comments i deals/{dealId}/comments)
    ////////////////////////////////
    // PRODUCT COMMENTS
    ////////////////////////////////
    match /products/{productId}/comments/{commentId} {
      allow read: if true; // komentarze produktów są publiczne gdy produkt approved
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid && stringMax('content',2000);
      allow update: if isOwner('userId') && stringMax('content',2000);
      allow delete: if isOwner('userId') || isAdmin();
    }

    // Oceny produktów: każdy może czytać, tylko właściciel może dodawać/edytować swoją ocenę
    ////////////////////////////////
    // PRODUCT RATINGS (po jednej na usera)
    ////////////////////////////////
    match /products/{productId}/ratings/{userId} {
      allow read: if true;
      allow create: if isSignedIn() && request.auth.uid == userId && !request.resource.data.keys().hasAny(['average','count']);
      allow update: if isSignedIn() && request.auth.uid == userId;
      allow delete: if isSignedIn() && (request.auth.uid == userId || isAdmin());
    }

    ////////////////////////////////
    // DEAL COMMENTS
    ////////////////////////////////
    match /deals/{dealId}/comments/{commentId} {
      allow read: if true; // komentarze są publiczne przy approved dealu
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid && stringMax('content',2000);
      allow update: if isOwner('userId') && stringMax('content',2000);
      allow delete: if isOwner('userId') || isAdmin();
    }

    
    // Głosy jako subkolekcje: Każdy może czytać. Zapis tylko dla właściciela głosu.
    // Zmiana temperature jest dozwolona przez transakcję w update deala
    ////////////////////////////////
    // DEAL VOTES
    ////////////////////////////////
    match /deals/{dealId}/votes/{userId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && request.auth.uid == userId;
    }

    // Ulubione: Użytkownik może zarządzać tylko swoimi ulubionymi
    ////////////////////////////////
    // FAVORITES
    ////////////////////////////////
    match /favorites/{favoriteId} {
  allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // Powiadomienia: Użytkownik może czytać, aktualizować i usuwać tylko swoje powiadomienia
    // Tworzenie mogą tylko admini lub system (Cloud Functions)
    ////////////////////////////////
    // NOTIFICATIONS
    ////////////////////////////////
    match /notifications/{notificationId} {
  allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow create: if isSignedIn() && (isAdmin() || request.resource.data.userId == request.auth.uid);
    }
  }
}
